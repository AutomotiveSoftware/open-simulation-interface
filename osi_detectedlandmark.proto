syntax = "proto2";

option optimize_for = SPEED;

import "osi_common.proto";
import "osi_landmark.proto";
import "osi_detectedobject.proto";

package osi;

//
// \brief A traffic sign in the environment as detected by the sensor.
//
message DetectedTrafficSign
{
    // Specific ID of the traffic sign as assigned by the sensor internally.
    // Need not match with \c #ground_truth_id.
    //
    optional Identifier tracking_id = 2;

    // The ID of the original traffic sign in the ground truth.
    // In case of a ghost sign (no corresponding ground truth), this field
    // should be unset.
    //
    optional Identifier ground_truth_id = 3;

    // The main sign as estimated by the sensor.
    //
    optional EssentialMainSign main_sign = 4;
    
    // A list of additional supplementary sign(s) as estimated by the sensor.
    //
    repeated EssentialSupplementarySign supplementary_signs = 5;

    // The estimated probability that this traffic sign with all supplementary
    // signs really exists, not based on history.
    //
    // \note Use as confidence measure where a low value means less confidence
    // and a high value indicates strong confidence.
    //
    optional double existence_probability = 7;

    // Links to the corresponding lanes.
    // 
    repeated RelevantLane relevant_lanes = 10;
   
    // A list of sensors which detected this detected entity.
    //
    // If \c SensorData has detected entities and all detections are missing, 
    // then e.g. the number of sensors can confirm the 
    // \c #existence_probability.
    // 
    // \note This information can be determined via the detected entities'
    // detections ( \c ...Detection::object_id = 'this detected entity' ) and
    // the sensors (their IDs) to which these detections belong.
    //
    repeated Identifier sensor_ids = 11;    

    //
    // \brief Candidates for a detected sign as estimated by the sensor.
    //
    message EssentialMainSign
    {
        // A list of candidates for this traffic sign as estimated by the
        // sensor.
        // 
        repeated CandidateSign candidates = 1;

        // The root mean squared error of the base parameters of the detected
        // traffic sign. \c TrafficSign::base has to be identical for
        // all \c #candidates traffic signs.
        //
        optional BaseStationary base_rmse = 2;

        // The detected geometry of the traffic sign.
        // 
        optional Geometry geometry = 3;

        //
        // \brief A candidate for a detected traffic sign as estimated by the 
        // sensor.
        //
        message CandidateSign
        {
            // The definition of the candidate's properties.
            // The sign.id values of all CandidateSigns within one
            // \c DetectedTrafficSign correspond to the tracking ID and must be
            // identical.
            //
            optional TrafficSign.MainSign sign = 1;

            // The estimated probability that this candidate is the true value.
            // The sum of all \c #candidate_probability must be one.
            //
            // Range: [0,1]
            //
            optional double candidate_probability = 2;

            // The amount of time that this detected object has been currently 
            // observed/tracked.
            // 
            // Unit: [s]
            //
            optional double age = 3;

            // The measurement state.
            //
            optional MeasurementState measurement_state = 4;
        }

        // Definition of traffic sign geometries.
        //
        enum Geometry
        {
            // Geometry of the traffic sign is unknown (must not be used in 
            // ground truth).
            //
            GEOMETRY_UNKNOWN = 0;
            
            // Geometry of the traffic sign is unspecified (but known).
            // 
            GEOMETRY_OTHER = 1;
            
            // Traffic sign has a triangular geometry pointing to the top.
            // 
            GEOMETRY_TRIANGLE_TOP = 2;
            
            //Traffic sign has a triangular geometry pointing down.
            // 
            GEOMETRY_TRIANGLE_DOWN = 3;
            
            // Traffic sign has a circular geometry.
            // 
            GEOMETRY_CIRCLE = 4;
            
            // Traffic sign has a square geometry.
            // 
            GEOMETRY_SQUARE = 5;
            
            // Traffic sign has a diamond geometry.
            // 
            GEOMETRY_DIAMOND = 6;
            
            // Traffic sign has an octagon geometry.
            // 
            GEOMETRY_OCTAGON = 7;
            
            // Traffic sign has a geometry of an arrow pointing to the left.
            // 
            GEOMETRY_ARROW_LEFT = 8;
            
            // Traffic sign has a geometry of an arrow pointing to the right.
            // 
            GEOMETRY_ARROW_RIGHT = 9;
            
            // Traffic sign has a rectangle geometry. (width is bigger than
            // height e.g. one-way)
            //
            GEOMETRY_RECTANGLE = 10;
            
            // Traffic sign that has a pole geometry. (height is bigger than
            // width e.g. pole indicating highways exit in xx [m]).
            //
            GEOMETRY_POLE = 11;
            
            // Traffic sign that has an oversize rectangle geometry.
            // E.g. direction plates on highway or city signs.
            //
            GEOMETRY_PLATE = 12;
        }
    }

    //
    // \brief Candidates for all detected supplementary signs of one traffic
    // sign as estimated by the sensor.
    //
    message EssentialSupplementarySign
    {
        // The definition of one of more supplementary signs that together
        // define this candidate.
        //
        repeated CandidateSupplementarySign candidates = 1;

        // The root mean squared error of the base parameters of the detected
        // supplementary traffic sign. \c #candidates
        // \c SupplementarySign::base has to be identical for all 
        // \c #candidates supplementary traffic signs.
        //
        optional BaseStationary base_rmse = 2;

        // The estimated probability that this supplementary sign really
        // exists, not based on history.
        //
        // \note Use as confidence measure where a low value means less
        // confidence and a high value indicates strong confidence.
        //
        optional double existence_probability = 3;

        //
        // \brief A candidate for a detected supplementary sign as estimated by
        // the sensor.
        //
        message CandidateSupplementarySign
        {
            // The definition of one of more supplementary signs that together
            // define this candidate.
            //
            optional TrafficSign.SupplementarySign sign = 1;

            // The estimated probability that this candidate is the true value.
            // The sum of all \c #candidate_probability of one supplementary
            // sign must be one.
            //
            // Range: [0,1]
            //
            optional double candidate_probability = 2;

            // The amount of time that this detected object has been currently 
            // observed/tracked.
            // 
            // Unit: [s]
            //
            optional double age = 3;

            // The measurement state.
            //
            optional MeasurementState measurement_state = 4;
        }
    }
}

//
// \brief A traffic light in the environment as detected by the sensor.
//
message DetectedTrafficLight
{
    // Specific ID of the traffic light as assigned by the sensor internally.
    // Need not match with \c #ground_truth_id.
    //
    optional Identifier tracking_id = 2;

    // The ID of the original traffic light in the ground truth.
    // In case of a ghost detection (no corresponding ground truth), this field
    // should be unset.
    //
    optional Identifier ground_truth_id = 3;

    // The main sign as estimated by the sensor.
    //
    optional EssentialTrafficLight traffic_light = 4;

    // Determines for which directions the traffic light applies.
    //
    repeated RelevantDirection relevant_directions = 6;

    // Links to the corresponding lanes.
    //
    repeated RelevantLane relevant_lanes = 7;

    // The estimated probability that this traffic light really exists, not
    // based on history.
    //
    // \note Use as confidence measure where a low value means less confidence
    // and a high value indicates strong confidence.
    //
    optional double existence_probability = 8;
    
    // A list of sensors which detected this detected entity.
    //
    // If \c SensorData has detected entities and all detections are missing, 
    // then e.g. the number of sensors can confirm the 
    // \c #existence_probability.
    // 
    // \note This information can be determined via the detected entities'
    // detections ( \c ...Detection::object_id = 'this detected entity' ) and
    // the sensors (their IDs) to which these detections belong.
    //
    repeated Identifier sensor_ids = 10;    

    //
    // \brief Candidates for a detected traffic light as estimated by the 
    // sensor.
    //
    message EssentialTrafficLight
    {
        // A list of candidates for this traffic light as estimated by the 
        // sensor.
        //
        repeated CandidateTrafficLight candidates = 1;

        // The root mean squared error of the base parameters of the detected
        // traffic light's geometry. \c TrafficLight::base has to be identical
        // for all \c #candidates traffic lights.
        //
        optional BaseStationary base_rmse = 2;
    
        //
        // \brief A candidate for a detected traffic light as estimated by
        // the sensor.
        //
        message CandidateTrafficLight
        {
            // The definition of one traffic light that define this candidate.
            //
            optional TrafficLight traffic_light = 1;

            // The estimated probability that this candidate is the true value. 
            // The sum of all \c #candidate_probability must be one.
            //
            // Range: [0,1]
            //
            optional double candidate_probability = 2;

            // The amount of time that this detected object has been currently 
            // observed/tracked.
            // 
            // Unit: [s]
            optional double age = 3;

            // The measurement state.
            //
            optional MeasurementState measurement_state = 4;
        }
    }

    //
    // \brief Further specifies the relevant directions of the traffic light.
    //
    message RelevantDirection
    {
        // The direction the traffic light corresponds to.
        //
        optional Direction direction = 1;

        // Relevance probability. 
        //
        // Range: [0,1]
        //
        optional double relevance_probability = 2;

        // Specifies the different directions.
        //
        enum Direction
        {
            // Direction is unknown (must not be used in ground truth).
            //
            DIRECTION_UNKNOWN = 0;

            // Other (unspecified but known) direction.
            //
            DIRECTION_OTHER = 1;

            // Direction is straight.
            //
            DIRECTION_STRAIGHT = 2;

            // Direction is left.
            //
            DIRECTION_LEFT = 3;

            // Direction is right.
            //
            DIRECTION_RIGHT = 4;
        }
    }
}

//
// \brief Further specifies the relevant lane of a detected object.
//
message RelevantLane
{
    // Tracking ID of the lane segment.
    //
    optional Identifier lane_id = 1;

    // Relevance probability. 
    //
    // Range: [0,1]
    optional double relevance_probability = 2;
}

//
// \brief A road marking in the environment as detected by the sensor.
//
message DetectedRoadMarking
{
    // Specific ID of the road marking as assigned by the sensor internally.
    // Need not match with \c #ground_truth_id.
    //
    optional Identifier tracking_id = 2;

    // The ID of the original road marking in the ground truth.
    // In case of a ghost detection (no corresponding ground truth), this field
    // should be unset.
    //
    optional Identifier ground_truth_id = 3;

    // The road marking as estimated by the sensor.
    //
    optional EssentialRoadMarking road_marking = 4;

    // The estimated probability that this road marking really exists, not based
    // on history.
    //
    // \note Use as confidence measure where a low value means less confidence
    // and a high value indicates strong confidence.
    //
    optional double existence_probability = 5;

    // Links to the corresponding lanes.
    //
    repeated RelevantLane relevant_lanes = 6;
   
    // A list of sensors which detected this detected entity.
    //
    // If \c SensorData has detected entities and all detections are missing,
    // then e.g. the number of sensors can confirm the 
    // \c #existence_probability.
    // 
    // \note This information can be determined via the detected entities'
    // detections ( \c ...Detection::object_id = 'this detected entity' ) and
    // the sensors (their IDs) to which these detections belong.
    //
    repeated Identifier sensor_ids = 11;     

    //
    // \brief Candidates for a detected traffic light as estimated by the 
    // sensor.
    //
    message EssentialRoadMarking
    {
        // A list of candidates for this road marking as estimated by the 
        // sensor.
        //
        repeated CandidateRoadMarking candidates = 1;
    
        // The root mean squared error of the base parameters of the detected
        // road marking. \c RoadMarking::base has to be identical for
        // all \c #candidates road markings.
        //
        optional BaseStationary base_rmse = 2;
    
        //
        // \brief A candidate for a detected road marking as estimated by the sensor.
        //
        message CandidateRoadMarking
        {
            // The description of the road marking.
            //
            optional RoadMarking road_marking = 1;

            // The estimated probability that this candidate is the true value.
            // The sum of all \c #candidate_probability must be one.
            //
            // Range: [0,1]
            //
            optional double candidate_probability = 2;

            // The amount of time that this detected object has been currently 
            // observed/tracked.
            // 
            // Unit: [s]
            //
            optional double age = 3;

            // The measurement state.
            //
            optional MeasurementState measurement_state = 4;
        }
    }
}

//
// \brief A landmark in the environment as detected by the sensor.
//
message DetectedLandmark
{
    // Specific ID of the landmark as assigned by the sensor internally.
    // Need not match with \c #ground_truth_ids.
    //
    optional Identifier tracking_id = 1;

    // The ID of the original landmark in the ground truth.
    // In case of a ghost detection (no corresponding ground truth), this field
    // should be unset.
    //
    repeated Identifier ground_truth_ids = 2;

    // The landmark as estimated by the sensor.
    //
    optional EssentialLandmark landmark = 3;

    // The estimated probability that this landmark really exists, not based
    // on history.
    //
    // \note Use as confidence measure where a low value means less confidence
    // and a high value indicates strong confidence.
    //
    optional double existence_probability = 4;
       
    // A list of sensors which detected this detected entity.
    //
    // If \c SensorData has detected entities and all detections are missing, 
    // then e.g. the number of sensors can confirm the #existence_probability.
    // 
    // \note This information can be determined via the detected entities'
    // detections ( \c ...Detection::object_id = 'this detected entity' ) and
    // the sensors (their IDs) to which these detections belong.
    //
    repeated Identifier sensor_ids = 6;    

    //
    // \brief Candidates for a detected Landmark as estimated by the 
    // sensor.
    //
    message EssentialLandmark
    {
        // A list of candidates for this landmark as estimated by the sensor.
        //
        repeated CandidateLandmark candidates = 1;
   
        // The root mean squared error of the base parameters of the detected
        // landmark. \c Landmark::base has to be identical for
        // all \c #candidates landmark.
        //
        optional BaseStationary base_rmse = 2;
    
        //
        // \brief A candidate for a detected landmark as estimated by the sensor.
        //
        message CandidateLandmark
        {
            // The description of the landmark.
            //
            optional Landmark landmark = 1;

            // The estimated probability that this candidate is the true value.
            // The sum of all \c #candidate_probability must be one.
            //
            // Range: [0,1]
            //
            optional double candidate_probability = 2;

            // The amount of time that this detected object has been currently 
            // observed/tracked.
            // 
            // Unit: [s]
            //
            optional double age = 3;

            // The measurement state.
            //
            optional MeasurementState measurement_state = 4;
        }
    }
}
