syntax = "proto2";

option optimize_for = SPEED;

import "osi_common.proto";

package osi;

//
// \brief Interface for low level sensor data, in contrast to high level data after object hypothesis and tracking.
//
// All information regarding the environment is given with respect to the sensor coordinate system specified in \c LowLevelData::mounting_position. 
// When simulating multiple sensors, each sensor has an individual copy of LowLevelData in its own reference frame. This allows an independent treatment of the sensors.
//
 message LowLevelData
 {
     // Lidar detection list for multiple lidar sensors.
     //
     repeated DetectionLidarList detection_lidar_list = 1;

     // Radar detection list for multiple lidar sensors.
     //
     repeated DetectionRadarList detection_radar_list = 2;
}

//
// \brief The header attributes of each detection.
//
message DetectionHeader
{
   // Version number of detecion list messages.
   // 
   optional uint64 version = 1;
    
   // Time stamp at which the measurement was taken (not the time at which it was processed or at which it is transmitted) in the global synchronized time. 
   //
   optional Timestamp timestamp = 2;
    
   // Continuous up counter to identify the cycle.
   //
   optional uint32 cylcle_counter = 3;

   // Mounting position of the sensor (origin and orientation of the sensor coordinate system);
   // given relative to the middle of the rear axis of the host vehicle.
   // The detections are given in the detection coordinate system. 
   // The x-axis must be the angle bisector of the horizontal field of view in a right handed coordinate system. The x-y plane represents the horizontal field of view 
   // and the x-z plane the vertical field of view. It is a polar coordinate system for the horizontal field of view with distance and azimuth angle and a Cartesian 
   // representation for the vertical field of view with a z_bottom and a height. 
   //
   // The origin of the detection coordinate system is the sensor mounting pose in the ego coordinate system. The ego coordinate system is at the center of the rear axis 
   // (from the top view as well as from the side view) in the static case. The origin represents the current mounting pose to the best knowledge of the sensor. It 
   // includes the estimated 6-D pose estimation given by the calibration. The uncertainty of this estimation is given with the corresponding 6-D standard deviation. The 
   // estimation of the current origin does not include effects due to short-time dynamics, such as pitch angles from braking, but includes long-time calibration values, 
   // such as pitch angles from luggage in the trunk.
   optional MountingPosition mounting_position = 4;

   // Uncertainty of the mounting pose calibration should be included in the interface (x, y, z, yaw). Uncertainties of pitch and roll are integrated into the uncertainties 
   // of border attributes such as the distance root mean square error and the bottom point root mean square error.
   optional MountingPosition mounting_position_rmse = 5;

   // Data Qualifier expresses whether the content of this event can be used or not.
   //
   optional DataQualifier data_qualifier = 6;

   // \brief Data qualifier communicates the overall availability of the interface.
   enum DataQualifier
   {
       // Data is available.
       //
       DATA_AVAILABLE = 0;
       
       // Reduced data is available.
       //
       DATA_AVAILABLE_REDUCED = 1;
      
       // Data is not available.
       //
       DATA_NOT_AVAILABLE = 2;
   }
}

//
// \brief A list of lidar detection.
//
message DetectionLidarList
{
    // List of lidar detections.
    //
    repeated DetectionLidar detection = 1;
    
   // Header attributes of lidar detection.
   //
   optional DetectionHeader header = 2;
}

//
// \brief A point or vertical line in a lidar point cloud.
//
message DetectionLidar
{
   // Existence probability of the detection not based on history.
   //
   // \note Field need not be set if false_positive_rate and false_negative_rate is defined.
   optional double existence_probability = 1;
      
   // False positive rate.
   //
   // \note Field need not be set if existence_probability is defined.
   optional double false_positive_rate = 2;
   
   // False negative rate.
   //
   // \note Field need not be set if existence_probability is defined.
   optional double false_negative_rate = 3;
   
   // Object ID of the object to which this detection is associated to; ID = MAX(uint64) indicates no reference to an object.
   //
   optional Identifier object_id = 4;
   
   // Measured position of the detection, given in spherical coordinates in sensor coordinate system.
   //
   optional Spherical3d position = 5;

   // Root mean square error of the measured position of the detection.
   //
   optional Spherical3d position_rmse = 6;

   // Height field is required if multiple scan points are vertically clustered. Only vertical clustering allowed (z-Axis).
   // 
   optional double height = 7;
   
   // Root mean square error of the object height.
   // 
   optional double height_rmse = 8;

   // Intensity or equivalent value of the detection's echo
   // Unit: [%].
   optional double intensity = 9;

   // The free space probability in the range [0.0, 1.0] from the origin up to this detection, as given by the distance.
   // 
   optional double free_space_probability = 10;

   // Attributes of the detection.
   // 
   optional Classification classification = 11;
   
   // Definition of lidar detection classifications.
   // 
   enum Classification
   {
      // detection is unknown (must not be used in ground truth).
      //
      UNKNOWN = 0;
        
      // Other (unspecified but known) lidar detection.
      //
      OTHER = 1;
        
      // Invalid detection, not to be used for object tracking, of unspecified type (none of the other types applies).
      //
      INVALID = 2;
    
      // Noise.
      //
      NOISE = 3;
      
      // Spray.
      //
      SPRAY = 4;
      
      // Rain.
      //
      RAIN = 5;
      
      // Fog.
      //
      FOG = 6;
      
      // Underdrivable.
      //
      UNDERDRIVABLE = 7;
      
      // Ground.
      //
      GROUND = 8;
      
      // Sign gantry.
      //
      SIGN_GANTRY = 9;
   }
}

//
// \brief A list of radar detections.
//
message DetectionRadarList
{
    // List of radar detections constituting the radar detection list.
    //
    repeated DetectionRadar detection = 1;
    
   // Header attributes of radar detection.
   //
   optional DetectionHeader header = 2;
}

//
// \brief A radar detection.
//
message DetectionRadar
{
   // Existence probability of the detection, using e.g. SNR and RCS, not based on history.
   //
   // \note Field need not be set if false_positive_rate and false_negative_rate is defined.
   optional double existence_probability = 1;
      
   // False positive rate.
   //
   // \note Field need not be set if existence_probability is defined.
   optional double false_positive_rate = 2;
   
   // False negative rate.
   //
   // \note Field need not be set if existence_probability is defined.
   optional double false_negative_rate = 3;
   
   // Object ID of the object to which this detection is associated to; ID = MAX(uint64) indicates no reference to an object.
   // 
   optional Identifier object_id = 4;
   
   // Measured position of the detection, given in spherical coordinates in sensor coordinate system.
   //
   optional Spherical3d position = 5;

   // Root mean square error of the measured position of the detection.
   // 
   optional Spherical3d position_rmse = 6;
   
   // Absolute radial (in direction to the sensor) velocity of the detection.
   // 
   optional double radial_velocity = 7;
   
   // Root mean square error of the object measured radial velocity.
   // 
   optional double radial_velocity_rmse = 8;

   // The radar cross section (RCS) of the radar detection.
   // Unit: [dB m^2].
   optional double rcs = 9;

   // The signal to noise ratio (SNR) of the radar detection.
   // Unit: [dB m^2].
   optional double snr = 10;

   // Describes the possibility if more than one object has led to this detection.
   // 
   optional double point_target_probability = 11;

   // Ambiguity Information: 
   // Each ambiguous measurement generates one Ambiguity ID. Ambiguity is shown by the identical Ambiguity ID. 
   // Unambiguous measurements has Amiguity ID := 0.
   optional Identifier ambiguity_id = 12;
}
