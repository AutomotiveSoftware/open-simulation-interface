syntax = "proto2";

option optimize_for = SPEED;

import "osi_common.proto";
import "osi_lane.proto";
import "osi_detectedobject.proto";

package osi3;

//
// \brief A lane segment as detected by the sensor.
//
message DetectedLane
{
    // Common information of one detected item.
    //
    optional DetectedItemHeader header = 1;

    // The lane as detected by the sensor.
    //
    optional EstimatedLane lane = 3;

    //
    // \brief Candidates for a detected lane as estimated by the sensor.
    //
    message EstimatedLane
    {
        // A list of candidates for this lane as estimated by the sensor.
        //
        // \note OSI uses singular instead of plural for repeated field names.
        //
        repeated CandidateLane candidate = 1;

        //
        // \brief A candidate for a detected lane as estimated by the
        // sensor.
        //
        message CandidateLane
        {
            // Common information of one detected item candidate.
            //
            optional DetectedItemHeader.CandidateItemHeader header = 1;

            // The definition of one lane that defines this candidate.
            //
            // \note IDs, which are referenced in this message, usually
            // reference to \c DetectedXXX::tracking_id IDs.
            //
            optional Lane lane = 2;
        }
    }
}

//
// \brief A lane segment as detected by the sensor.
//
message DetectedLaneBoundary
{
    // Common information of one detected item.
    //
    optional DetectedItemHeader header = 1;

    // The lane boundary as detected by the sensor.
    //
    optional EstimatedLaneBoundary lane_boundary = 3;

    //
    // \brief Candidates for a detected lane boundary as estimated by the
    // sensor.
    //
    message EstimatedLaneBoundary
    {
        // A list of candidates for this lane boundary as estimated by the
        // sensor.
        //
        // \note OSI uses singular instead of plural for repeated field names.
        //
        repeated CandidateLaneBoundary candidate = 1;

        // The root mean squared error of the \c LaneBoundary.BoundaryPoint
        // information from a \c LaneBoundary.
        // For each \c #lane_boundary \c LaneBoundary::boundary_line point exact
        // one \c #boundary_line_rmse rmse information exist.
        //
        repeated LaneBoundary.BoundaryPoint boundary_line_rmse = 2;

        // Confidence of the segments of the \c LaneBoundary.BoundaryPoint
        // information from a \c LaneBoundary.
        // For each \c #lane_boundary \c LaneBoundary::boundary_line point exact
        // one \c #boundary_line_confidences confidence value is
        // specified.
        //
        repeated double boundary_line_confidences = 3;

        //
        // \brief A candidate for a detected lane boundary as estimated by the
        // sensor.
        //
        message CandidateLaneBoundary
        {
            // Common information of one detected item candidate.
            //
            optional DetectedItemHeader.CandidateItemHeader header = 1;

            // The definition of one lane boundary that defines this candidate.
            //
            // \note IDs, which are referenced in this message, usually
            // reference to \c DetectedXXX::tracking_id IDs.
            //
            optional LaneBoundary lane_boundary = 2;

            // Confidence of the classified lane boundary type.
            //
            optional double type_confidence = 5;

            // Confidence of the classified lane marker color.
            //
            optional double color_confidence = 6;
        }
    }
}
